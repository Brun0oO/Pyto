"""
Module used internally by Pyto for importing C extension.
"""

import sys
import importlib
import traceback

if __host__ is not widget:
    from sharing import open_url
    import urllib.parse

def report_error(module, trace_back, e):
    """
    Sends an E-mail reporting error.
    
    Args:
        module: The module's that cannot be imported name.
        trace_back: Traceback as string.
    """

    try:
        from pyto_ui import Alert
        alert = Alert(title=module, message="An error occurred while importing "+module+".\n\nDo you want to report error to the developer?")
        alert.add_action("Report")
        alert.add_cancel_action("Cancel")

        if alert.show() == "Report":
            open_url("mailto:adrian@develobile.com?subject="+module+"%20Importing%20Error&body="+urllib.parse.quote(trace_back))
    except ImportError:
        pass

# MARK: - NumPy

class NumpyImporter(object):
    """
    Meta path for importing NumPy to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        if fullname in ('numpy.core._multiarray_umath', 'numpy.fft.fftpack_lite', 'numpy.linalg._umath_linalg', 'numpy.linalg.lapack_lite', 'numpy.random.mtrand'):
            return self
        
        if fullname == 'numpy' and not self.__is_importing__:
            return self
        
        return
    
    def load_module(self, fullname):
        f = fullname
        if f != 'numpy':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        if mod is None:
            def importMod():
                mod = importlib.__import__(f)
                sys.modules[fullname] = mod
            
            if fullname != 'numpy' or __host__ is widget:
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    pass
                except SystemExit:
                    pass
                except Exception as e:
                    print(e)
                    report_error('Numpy', traceback.format_exc(), e)
                    raise
                finally:
                    self.__is_importing__ = False

            return mod
        
        return mod

# MARK: - Matplotlib

class MatplotlibImporter(object):
    """
    Meta path for importing Matplotlib to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        if fullname in ('matplotlib.backends._backend_agg', 'matplotlib._path', 'matplotlib._image', 'matplotlib._png', 'matplotlib.ft2font', 'matplotlib._contour', 'matplotlib._qhull', 'matplotlib._tri', 'matplotlib.ttconv', 'matplotlib._cntr', 'matplotlib._delaunay'):
            return self
        
        if fullname == 'matplotlib' and not self.__is_importing__:
            return self
        
        return
    
    def load_module(self, fullname):
        f = fullname
        if f != 'matplotlib':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        if mod is None:
            def importMod():
                mod = importlib.__import__(f)
                sys.modules[fullname] = mod
            
            if fullname != 'matplotlib' or __host__ is widget:
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    return
                except SystemExit:
                    return
                except Exception as e:
                    print(e)
                    report_error('Matplotlib', traceback.format_exc(), e)
                    raise
                finally:
                    self.__is_importing__ = False
            
            return mod
        
        return mod

# MARK: - Pandas

class PandasImporter(object):
    """
    Meta path for importing Pandas to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        
        if fullname == 'pandas' and not self.__is_importing__:
            return self
        
        if fullname in ('pandas._libs.writers', 'pandas.io.msgpack._packer', 'pandas.io.sas._sas', 'pandas._libs.hashtable', 'pandas._libs.reshape', 'pandas._libs.tslib', 'pandas._libs.interval', 'pandas._libs.missing', 'pandas._libs.ops', 'pandas.io.msgpack._unpacker', 'pandas._libs.hashing', 'pandas._libs.join', 'pandas._libs.sparse', 'pandas._libs.indexing', 'pandas._libs.parsers', 'pandas._libs.algos', 'pandas._libs.reduction', 'pandas._libs.testing', 'pandas._libs.properties', 'pandas._libs.internals', 'pandas._libs.window', 'pandas._libs.json', 'pandas._libs.index', 'pandas._libs.groupby', 'pandas._libs.skiplist', 'pandas._libs.lib', 'pandas.util._move', 'pandas._libs.tslibs.ccalendar', 'pandas._libs.tslibs.conversion', 'pandas._libs.tslibs.fields', 'pandas._libs.tslibs.nattype', 'pandas._libs.tslibs.timedeltas', 'pandas._libs.tslibs.frequencies', 'pandas._libs.tslibs.resolution', 'pandas._libs.tslibs.offsets', 'pandas._libs.tslibs.np_datetime', 'pandas._libs.tslibs.period', 'pandas._libs.tslibs.timezones', 'pandas._libs.tslibs.strptime', 'pandas._libs.tslibs.parsing', 'pandas._libs.tslibs.timestamps'):
            return self
        
        return
    
    def load_module(self, fullname):
        f = fullname
        if f != 'pandas':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        if mod is None:
            def importMod():
                mod = importlib.__import__(f)
                sys.modules[fullname] = mod
            
            if fullname != 'pandas' or __host__ is widget:
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    return
                except SystemExit:
                    return
                except Exception as e:
                    print(e)
                    report_error('Pandas', traceback.format_exc(), e)
                    raise
                finally:
                    self.__is_importing__ = False
            
            return mod
        
        return mod

# MARK: - Pillow

class PillowImporter(object):
    """
    Meta path for importing Pillow to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        if fullname in ('PIL._imaging', 'PIL._imagingft', 'PIL._imagingmath', 'PIL._imagingmorph', 'PIL._imagingtk'):
            return self
        
        if fullname == 'PIL' and not self.__is_importing__:
            return self
        
        return
    
    def load_module(self, fullname):
        f = fullname
        if f != 'PIL':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        if mod is None:
            def importMod():
                mod = importlib.__import__(f)
                sys.modules[fullname] = mod
            
            if fullname != 'PIL':
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    pass
                except SystemExit:
                    pass
                except Exception as e:
                    print(e)
                    report_error('Pillow', traceback.format_exc(), e)
                    raise
                finally:
                    self.__is_importing__ = False

            return mod
        
        return mod

# MARK: - Biopython

class BiopythonImporter(object):
    """
    Meta path for importing Biopython to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        if fullname in ('Bio.Align._aligners', 'Bio.KDTree._CKDTree', 'Bio.Cluster._cluster', 'Bio.motifs._pwm', 'Bio.Nexus.cnexus', 'Bio.cpairwise2', 'Bio.PDB.kdtrees', 'Bio.PDB.QCPSuperimposer.qcprotmodule', 'Bio.trie'):
            return self
        
        if fullname == 'Bio' and not self.__is_importing__:
            return self
        
        return
    
    def load_module(self, fullname):
        f = fullname
        if f != 'Bio':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        if mod is None:
            def importMod():
                mod = importlib.__import__(f)
                sys.modules[fullname] = mod
            
            if fullname != 'Bio' or __host__ is widget:
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    pass
                except SystemExit:
                    pass
                except Exception as e:
                    print(e)
                    report_error('Biopython', traceback.format_exc(), e)
                    raise
                finally:
                    self.__is_importing__ = False

            return mod
        
        return mod

# MARK: - LXML

class LXMLImporter(object):
    """
    Meta path for importing LXML to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        
        if fullname == 'lxml' and not self.__is_importing__:
            return self
                
        if fullname in ('lxml._elementpath', 'lxml.builder', 'lxml.etree', 'lxml.html.clean', 'lxml.html.diff', 'lxml.objectifiy', 'lxml.sax'):
            return self
        
        return
    
    def load_module(self, fullname):
        f = fullname
        if f != 'lxml':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        if mod is None:
            def importMod():
                mod = importlib.__import__(f)
                sys.modules[fullname] = mod
            
            if fullname != 'lxml' or __host__ is widget:
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    return
                except SystemExit:
                    return
                except Exception as e:
                    print(e)
                    report_error('LXML', traceback.format_exc(), e)
                    raise
                finally:
                    self.__is_importing__ = False
            
            return mod
        
        return mod

# MARK: - SciPy

# Thanks to @goodclass for the amazing work!!!!!!

class ScipyImporter(object):
    """
    Meta path for importing Scipy to be added to `sys.meta_path`.
    """

    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        if fullname in ('scipy.odr.__odrpack', 'scipy.cluster._optimal_leaf_ordering', 'scipy.cluster._vq', 'scipy.cluster._hierarchy', 'scipy.ndimage._ni_label', 'scipy.ndimage._nd_image', 'scipy.ndimage._ctest_oldapi', 'scipy.ndimage._cytest', 'scipy.ndimage._ctest', 'scipy.linalg._solve_toeplitz', 'scipy.linalg._flinalg', 'scipy.linalg._decomp_update', 'scipy.linalg._interpolative', 'scipy.linalg.cython_blas', 'scipy.linalg._flapack', 'scipy.linalg._fblas', 'scipy.linalg.cython_lapack', 'scipy.optimize._zeros', 'scipy.optimize._minpack', 'scipy.optimize._trlib._trlib', 'scipy.optimize._slsqp', 'scipy.optimize._group_columns', 'scipy.optimize._cobyla', 'scipy.optimize._lsq.givens_elimination', 'scipy.optimize.minpack2', 'scipy.optimize._lbfgsb', 'scipy.optimize._nnls', 'scipy.optimize.moduleTNC', 'scipy.integrate._odepack', 'scipy.integrate._test_multivariate', 'scipy.integrate._test_odeint_banded', 'scipy.integrate.lsoda', 'scipy.integrate.vode', 'scipy.integrate._quadpack', 'scipy.integrate._dop', 'scipy.io.matlab.streams', 'scipy.io.matlab.mio5_utils', 'scipy.io.matlab.mio_utils', 'scipy.io._test_fortran', 'scipy._lib._fpumode', 'scipy._lib._ccallback_c', 'scipy._lib.messagestream', 'scipy._lib._test_ccallback', 'scipy.special._comb', 'scipy.special.cython_special', 'scipy.special._ufuncs', 'scipy.special._test_round', 'scipy.special.specfun', 'scipy.special._ufuncs_cxx', 'scipy.special._ellip_harm_2', 'scipy.fftpack._fftpack', 'scipy.fftpack.convolve', 'scipy.interpolate.dfitpack', 'scipy.interpolate._bspl', 'scipy.interpolate._ppoly', 'scipy.interpolate.interpnd', 'scipy.interpolate._fitpack', 'scipy.interpolate._interpolate', 'scipy.sparse.linalg.isolve._iterative', 'scipy.sparse.linalg.eigen.arpack._arpack', 'scipy.sparse.linalg.dsolve._superlu', 'scipy.sparse._sparsetools', 'scipy.sparse.csgraph._reordering', 'scipy.sparse.csgraph._min_spanning_tree', 'scipy.sparse.csgraph._tools', 'scipy.sparse.csgraph._traversal', 'scipy.sparse.csgraph._shortest_path', 'scipy.sparse._csparsetools', 'scipy.spatial.qhull', 'scipy.spatial._voronoi', 'scipy.spatial._hausdorff', 'scipy.spatial.ckdtree', 'scipy.spatial._distance_wrap', 'scipy.signal._upfirdn_apply', 'scipy.signal.sigtools', 'scipy.signal._peak_finding_utils', 'scipy.signal._spectral', 'scipy.signal.spline', 'scipy.signal._max_len_seq_inner', 'scipy.stats.statlib', 'scipy.stats.mvn', 'scipy.stats._stats'):
            return self
        
        if fullname == 'scipy' and not self.__is_importing__:
            return self
        return
    
    def load_module(self, fullname):
        f = fullname
        if f != 'scipy':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        
        if mod is None:
            def importMod():
                mod = importlib.__import__(f)
                sys.modules[fullname] = mod
            
            if fullname != 'scipy':
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    pass
                except SystemExit:
                    pass
                except Exception as e:
                    print(e)
                    report_error('scipy', traceback.format_exc(), e)
                    raise
                finally:
                    self.__is_importing__ = False
            
            return mod
        return mod

# MARK: - SkLearn

class SkLearnImporter(object):
    """
    Meta path for importing SkLearn to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        if fullname in ('sklearn.tree._tree', 'sklearn.tree._criterion', 'sklearn.tree._splitter', 'sklearn.tree._utils', 'sklearn.metrics.cluster.expected_mutual_info_fast', 'sklearn.metrics.pairwise_fast', 'sklearn.ensemble._gradient_boosting', 'sklearn.cluster._k_means', 'sklearn.cluster._hierarchical', 'sklearn.cluster._dbscan_inner', 'sklearn.cluster._k_means_elkan', 'sklearn.feature_extraction._hashing', 'sklearn.__check_build._check_build', 'sklearn.datasets._svmlight_format', 'sklearn.linear_model.sgd_fast', 'sklearn.linear_model.sag_fast', 'sklearn.linear_model.cd_fast', 'sklearn.utils.arrayfuncs', 'sklearn.utils.graph_shortest_path', 'sklearn.utils.murmurhash', 'sklearn.utils.sparsefuncs_fast', 'sklearn.utils.fast_dict', 'sklearn.utils.weight_vector', 'sklearn.utils._logistic_sigmoid', 'sklearn.utils.seq_dataset', 'sklearn.utils.lgamma', 'sklearn.utils._random', 'sklearn._isotonic', 'sklearn.svm.libsvm', 'sklearn.svm.liblinear', 'sklearn.svm.libsvm_sparse', 'sklearn.manifold._barnes_hut_tsne', 'sklearn.manifold._utils', 'sklearn.decomposition.cdnmf_fast', 'sklearn.decomposition._online_lda', 'sklearn.neighbors.quad_tree', 'sklearn.neighbors.typedefs', 'sklearn.neighbors.ball_tree', 'sklearn.neighbors.dist_metrics', 'sklearn.neighbors.kd_tree'):
            return self
        
        if fullname == 'sklearn' and not self.__is_importing__:
            return self
        
        return
    
    def load_module(self, fullname):
        f = fullname
        if f != 'sklearn':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        
        if mod is None:
            def importMod():
                mod = importlib.__import__(f)
                sys.modules[fullname] = mod
            
            if fullname != 'sklearn':
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    pass
                except SystemExit:
                    pass
                except Exception as e:
                    print(e)
                    report_error('SciKit-Learn', traceback.format_exc(), e)
                    raise
                finally:
                    self.__is_importing__ = False
            
            return mod
        return mod

class SkImageImporter(object):
    """
    Meta path for importing SkImage to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        
        if fullname == 'skimage' and not self.__is_importing__:
            return self
        
        if fullname in ('skimage.filters._ctmf', 'skimage.filters.rank.bilateral_cy', 'skimage.filters.rank.generic_cy', 'skimage.filters.rank.percentile_cy', 'skimage.filters.rank.core_cy', 'skimage.restoration._denoise_cy', 'skimage.restoration._unwrap_1d', 'skimage.restoration._unwrap_2d', 'skimage.restoration._nl_means_denoising', 'skimage.restoration._unwrap_3d', 'skimage.segmentation._felzenszwalb_cy', 'skimage.segmentation._slic', 'skimage.segmentation._quickshift_cy', 'skimage.io._plugins._colormixer', 'skimage.io._plugins._histograms', 'skimage.graph._mcp', 'skimage.graph._spath', 'skimage.graph.heap', 'skimage.measure._ccomp', 'skimage.measure._pnpoly', 'skimage.measure._marching_cubes_classic_cy', 'skimage.measure._marching_cubes_lewiner_cy', 'skimage.measure._find_contours_cy', 'skimage.measure._moments_cy', 'skimage._shared.transform', 'skimage._shared.interpolation', 'skimage._shared.geometry', 'skimage.morphology._extrema_cy', 'skimage.morphology._skeletonize_3d_cy', 'skimage.morphology._convex_hull', 'skimage.morphology._greyreconstruct', 'skimage.morphology._skeletonize_cy', 'skimage.morphology._watershed', 'skimage.feature._texture', 'skimage.feature.orb_cy', 'skimage.feature._hoghistogram', 'skimage.feature.brief_cy', 'skimage.feature.censure_cy', 'skimage.feature._haar', 'skimage.feature._hessian_det_appx', 'skimage.feature.corner_cy', 'skimage.external.tifffile._tifffile', 'skimage.transform._warps_cy', 'skimage.transform._hough_transform', 'skimage.transform._radon_transform', 'skimage.transform._seam_carving', 'skimage.draw._draw', 'skimage.future.graph._ncut_cy'):
            return self
        
        return
    
    def load_module(self, fullname):
        f = fullname
        if f != 'skimage':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        if mod is None:
            def importMod():
                mod = importlib.__import__(f)
                sys.modules[fullname] = mod
            
            if fullname != 'skimage' :
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    return
                except SystemExit:
                    return
                except Exception as e:
                    print(e)
                    report_error('SciKit-Image', traceback.format_exc(), e)
                    raise
                finally:
                    self.__is_importing__ = False
            
            return mod
        return mod

# Pywt

class PywtImporter(object):
    """
    Meta path for importing Pywt to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        
        if fullname == 'pywt' and not self.__is_importing__:
            return self
        
        if fullname in ('pywt._extensions._cwt', 'pywt._extensions._dwt', 'pywt._extensions._swt', 'pywt._extensions._pywt'):
            return self
        
        return
    
    def load_module(self, fullname):
        f = fullname
        if f != 'pywt':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        if mod is None:
            def importMod():
                mod = importlib.__import__(f)
                sys.modules[fullname] = mod
            
            if fullname != 'pywt' :
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    return
                except SystemExit:
                    return
                except Exception as e:
                    print(e)
                    report_error('Pywt', traceback.format_exc(), e)
                    raise
                finally:
                    self.__is_importing__ = False
            
            return mod
        return mod

# MARK: - All

__all__ = ['NumpyImporter', 'MatplotlibImporter', 'PandasImporter', 'PillowImporter', 'BiopythonImporter', 'LXMLImporter', 'ScipyImporter', 'SkLearnImporter', 'SkImageImporter', 'PywtImporter']
